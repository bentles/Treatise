#LyX 2.1 created this file. For more info see http://www.lyx.org/
\lyxformat 474
\begin_document
\begin_header
\textclass article
\use_default_options true
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_math auto
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100
\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\float_placement tph
\paperfontsize default
\spacing single
\use_hyperref false
\papersize default
\use_geometry false
\use_package amsmath 1
\use_package amssymb 1
\use_package cancel 1
\use_package esint 1
\use_package mathdots 1
\use_package mathtools 1
\use_package mhchem 1
\use_package stackrel 1
\use_package stmaryrd 1
\use_package undertilde 1
\cite_engine basic
\cite_engine_type default
\biblio_style plain
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\justification true
\use_refstyle 1
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Title
A JIT-Less Type-Mapped Dynamic-ISA Virtual Machine for Many-Instance Application
s
\end_layout

\begin_layout Standard
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "2pt"

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
centerline{ 
\end_layout

\end_inset


\begin_inset Graphics
	filename /home/stevetest/Documents/University/Treatise/image1.jpeg
	lyxscale 50
	scale 50

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout

\end_layout

\end_inset


\end_layout

\begin_layout Author
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
centerline{ 
\end_layout

\end_inset

Author: Douglas Bentley
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Author
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
centerline{ 
\end_layout

\end_inset

Supervisor: Kevin Naudé
\begin_inset ERT
status open

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset line
LatexCommand rule
offset "0.5ex"
width "100col%"
height "2pt"

\end_inset


\end_layout

\begin_layout Title
Submitted in partial fulfilment of the degree Baccalaureus Scientiae (Honores)
 in Computer Science at the Nelson Mandela Metropolitan University
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
Acknowledgements
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
Abstract
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
Declaration of Own Work
\end_layout

\begin_layout Paragraph
I declare that the entirety of the work contained in this treatise is my
 own, original work, that I am the sole author thereof (save to the extent
 explicitly otherwise stated), that reproduction and publication thereof
 by Nelson Mandela Metropolitan University will not infringe any third party
 rights that I have not previously in its entirety or in part submitted
 it for obtaining any qualification.
 
\end_layout

\begin_layout Paragraph
Signature:..................
 Date:..................
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
List of Figures
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
List of Tables
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section*
Table of Contents
\end_layout

\begin_layout Standard

\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Introduction
\end_layout

\begin_layout Subsection
Virtual Machines
\end_layout

\begin_layout Paragraph
To best describe the virtual machine presented in this treatise, a quick
 summary of virtual machines follows.
 The heirarchy of virtual machines is presented and our virtual machine
 is situated within it.
 Some important virtual machine terminology is introduced.
\end_layout

\begin_layout Subsubsection
What is a Virtual Machine?
\end_layout

\begin_layout Paragraph
A 
\emph on
virtual machine
\emph default
 or 
\emph on
VM
\emph default
 is a computer program that 
\begin_inset Quotes eld
\end_inset

executes software in the same manner as the machine for which the software
 was developed
\begin_inset Quotes erd
\end_inset

 
\begin_inset CommandInset citation
LatexCommand cite
after "pg9"
key "JamesE.Smith2005"

\end_inset

.
 This program is designed to run on some real machine.
 We call the real machine that a virtual machine is running on the 
\emph on
host
\emph default
 and the virtual machine the 
\emph on
guest.
 
\emph default
The guest machine provides an execution environment for software that is
 designed to run either on the guest itself or on an actual machine that
 the virtual machine is emulating.
 This means that we can use a virtual machine to run programs that are incompata
ble with the host.
 The virtual machine allows this by providing a mapping of its state to
 the state of the host machine on which it is running 
\begin_inset CommandInset citation
LatexCommand cite
after "pg4"
key "JamesE.Smith2005"

\end_inset

.
\end_layout

\begin_layout Subsubsection
The Types of Virtual Machines
\end_layout

\begin_layout Paragraph
Virtual machines come in two varieties: 
\emph on
process 
\emph default
virtual machines and 
\emph on
system
\emph default
 virtual machines.
 
\end_layout

\begin_layout Paragraph
A process virtual machine is 
\begin_inset Quotes eld
\end_inset

capable of supporting an individual process
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "pg9"
key "JamesE.Smith2005"

\end_inset

.
 This means that the host runs the guest for as long as a process on the
 guest machine needs it.
 Once the process has completed its execution the guest machine terminates
\begin_inset CommandInset citation
LatexCommand cite
after "pg9"
key "JamesE.Smith2005"

\end_inset

.
 An example of a process virtual machine is the Java Virtual Machine or
 JVM.
 All java programs run on the JVM.
 An instance of the JVM is started when you execute a java program and killed
 when its execution is complete.
\end_layout

\begin_layout Paragraph
A system virtual machine 
\begin_inset Quotes eld
\end_inset

provides a complete system environment
\begin_inset Quotes erd
\end_inset

 
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "pg9"
key "JamesE.Smith2005"

\end_inset

.
 This means that it can support an entire operating system on the guest
 machine and the many processes that the guest operating system executes.
 A system virtual machine will terminate when the system is shut down.
\end_layout

\begin_layout Subsubsection
The Types of Process Virtual Machines
\end_layout

\begin_layout Paragraph
Since this treatise outlines a process virtual machine we shall look at
 the different types of process virtual machines and ignore the finer details
 of system virtual machines.
 Process virtual machines can be divided into two categories: 
\emph on
multiprogrammed
\emph default
 
\emph on
systems
\emph default
 and 
\emph on
dynamic
\emph default
 
\emph on
translators
\emph default
.
 These are divided along whether or not the guest machine uses the same
 instruction set architecture as the host machine.
\end_layout

\begin_layout Paragraph
With multiprogramming the guest and host use the same instruction set.
 Multiprogramming is supported by most operating systems and allows a user
 to run many processes at once by making each process think it has access
 to an entire machine instead of only part of a machine 
\begin_inset Quotes erd
\end_inset


\begin_inset CommandInset citation
LatexCommand cite
after "pg13"
key "JamesE.Smith2005"

\end_inset

.
 The OS creates an environment per process that it terminates when that
 process ends execution.
 
\end_layout

\begin_layout Paragraph
With dynamic translators the instruction set of the host and guest generally
 do not match.
 The virtual machine translates blocks of instructions meant for the machine
 it is emulating and translates them into instructions to be run on the
 host.
 Not all code is translated in a dynamic translater.
 Only code that is used often enough will be translated as there is an overhead
 involved with translating code.
 The code that is not translated is interpreted.
 Interpreted instructions are read, their meaning interpreted and then executed.
 This interpretation step must happen each time a piece of code is executed
 so code that is executed enough times will be dynamically translated and
 cached so later execution is faster.
 Dynamically translating in this manner is known as ju
\emph on
st-in-time compilation
\emph default
 (JIT compilation).
\end_layout

\begin_layout Subsubsection
Dynamic vs Statically Typed Programming Languages
\end_layout

\begin_layout Paragraph
A dynamically typed language is one in which the type information is associated
 with values 
\begin_inset CommandInset citation
LatexCommand cite
after "pg4"
key "RobertoIerusalimschy"

\end_inset

(REF lua VM intro).
 An example of a dynamically typed language is javascript where the var
 keyword is used for variables and the type is inferred from the value stored
 into a variable.
 A statically typed language is one in which the type information is associated
 with the variable.
 An example of this is java where variables are declared using keywords
 that define their type (
\emph on
int
\emph default
, 
\emph on
string
\emph default
 etc).
\end_layout

\begin_layout Subsubsection
Where Our VM is Situated
\end_layout

\begin_layout Paragraph
The virtual machine described in this treatise is a process virtual machine.
 This process machine will have a new instruction set architecture and hence
 will differ from any host machine's ISA.
 The virtual machine does not make use of JIT compilation.
 It is entirely interpreted.
 It is also dynamically typed.
\end_layout

\begin_layout Subsection
A Virtual Machine for Many Instance Applications
\end_layout

\begin_layout Paragraph
Modern process virtual machines make use of JIT compilers.
 Both JVM and .Net make use of a JIT compiler 
\begin_inset CommandInset citation
LatexCommand cite
key "MSDN,Oracle"

\end_inset

.
 For applications that run many concurrent instances, like a web server
 which which starts up a new process for every client, a virtual machine
 that makes use of a JIT compiler defeats the benefits of read-only memory
 sharing.
 Since memory sharing is not possible when using a JIT compiler, if we wish
 to take advantage of it a JIT-less virtual machine is needed.
 However the JIT compiler compiler is an important feature of a VM that
 allows for code given to it at runtime to be compiled into machine code
 that can run directly on the host.
 This compiled code is cached and allows for future execution to be faster.
 Sacrificing the JIT compiler to allow memory sharing presents us with a
 need to find alternative ways to let our programs execute quickly.
\end_layout

\begin_layout Subsubsection
Type-Mapping
\end_layout

\begin_layout Paragraph
The idea to be explored for a more performant JIT-Less VM for a dynamically
 typed language is to make use of a 
\emph on
finite state space
\emph default
.
 The VM has a small number of registers and instructions that it can perform.
 For a dynamically typed VM these instructions may be able to take arguments
 of different types.
 For instance an instruction to add may take two integers or an integer
 and a float or two floats.
 The instruction has to discover the types of the arguments and perform
 the correct action.
 A finite state machine can be used to keep track of the types of the values
 in all of the registers.
 Whenever the type in a register is changed, the finite state machine makes
 a state transition that keeps track of that change.
 This means we can use the state of the finite state machine to jump to
 specialised versions of each instruction for each combination of inputs.
 This is an untested approach that may improve the performance of our VM.
\end_layout

\begin_layout Subsection
Project Scope
\end_layout

\begin_layout Paragraph
The project is to develop an implementation of a VM of this nature and run
 predetermined benchmarks on it against an alternate version of it that
 does not make use of type-mapping.
 This experiment should show what benefits the approach has.
 The VM will only have around 35 instructions and 2 types: integer and pointer.
 There will be no compiler or assembler implementation required and the
 VM will not be required to perform garbage collection.
 The VM will also not have to be robust in how it interacts with the operating
 system it is running on nor in how it handles errors.
\end_layout

\begin_layout Subsection
Risks
\end_layout

\begin_layout Paragraph
The risks of the project are mainly about its structure and how it can be
 criticised.
 The VM will be running predefined benchmarks.
 If it performs those well at the expense of its general usefulness the
 project can be criticised.
 All of these sorts of criticisms can be mitigated so long as the goal of
 the project is kept in mind at all times.
 Learning as much as possible about how well the idea works should always
 take precedence over trying to make results look good.
 Whether the VM performs better or not is important knowledge and being
 as careful as possible about discovering that accurately is extremely important.
\end_layout

\begin_layout Subsection
Overview of Treatise
\end_layout

\begin_layout Paragraph
To be completed
\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Section
Literature Review, Existing systems and Modern Processors
\end_layout

\begin_layout Subsection
Modern Processor Architecture
\end_layout

\begin_layout Paragraph
In order to create an efficient VM, we need first understand how modern
 processors work and what some of the bottlenecks for our VM's execution
 might be.
 For example, 
\emph on
threading techniques
\emph default
 (not to be confused with threads in application programming) are commonly
 used in VM design.
 These take advantage of a feature of modern processors called the 
\emph on
Branch Target Buffer
\emph default
 or BTB.
 The BTB exists to aid a process called 
\emph on
branch prediction
\emph default
.
 Branch prediction itself can only be explained once we know about how modern
 processors make use of 
\emph on
pipelining
\emph default
 to increase their throughput.
 As you can see, an understanding of modern computer architectures is needed
 before we can begin a discussion of VM design.
\end_layout

\begin_layout Subsubsection
Pipelining
\end_layout

\begin_layout Paragraph
Pipelining is a process in which a processor's instruction processing cycle
 is shared by many consecutive instructions at once.
 The instruction processing procedure is split up into smaller stages that
 can execute simultaneously.
 An example of this is the classic RISC pipeline[x] which to divides instruction
 processing into the following steps: Instruction Fetch (IF), Decode (ID),
 Execute(EX), Memory Access (MEM) and Writeback (WB).
 Each instruction passes a stage and leaves that part of the processor free
 to perform that stage on the next instruction.
 Thus many instructions (as many as there are stages) can be processed at
 once, instead of each instruction having to be completely processed before
 the processor is free to move onto the next instruction.
 The process is analogous to an asssembly line, where many cars can be assembled
 at the same time, each in a different stage of assembly.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Graphics
	filename pipeline.png
	scale 50

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
In 
\emph on
fig1
\emph default
 we see that the first instruction as currently performing MEMory access
 while the second EXecutes and the third is being Decoded.
 Up to 5 instructions can be processed simultaneously.
\end_layout

\begin_layout Paragraph
When pipelining an interesting situation occurs in the case of flow control
 instructions.
 These are instructions that cause execution to move to some other point
 in the program.
 The point at which we know which instruction comes next (called 
\emph on
branch resolution
\emph default
) is usually later in the pipeline.
 Thus the processor cannot queue up the next instruction as it does not
 know which instruction will execute next.
 Branch prediction is used in modern processors to try to keep the pipeline
 as full as possible and not waste time waiting for this information to
 be known.
\end_layout

\begin_layout Subsubsection
Branch Prediction
\end_layout

\begin_layout Paragraph
Instead of filling up the pipeline with no operation instructions until
 we know where to branch, with branch prediction we guess which branch will
 be taken and place the instructions from the predicted branch into the
 pipeline.
 When we know where the branch operation should have taken execution we
 either throw out our newly pipelined instructions (this is called 
\emph on
pipeline flushing
\emph default
) if the prediction was incorrect or continue execution if it was correct.
 The more stages the pipeline has before branch resolution, the more of
 a performance benefit correct predictions become for programs with many
 control flow instructions.
 A Virtual Machine is such a program.
 This is because a VM must branch to the correct code for each instruction
 it executes.
 Writing code that allows for increased branch prediction accuracy is thus
 very important for VM efficiency.
 
\end_layout

\begin_layout Paragraph
Predicting a branch means we must predict if that branch is taken or not
 and what the target of that branch is if it is taken.
 Modern processors have a Branch Target Buffer where the target adresses
 of previously taken branches are cached.
 So upon arrival at a branch that has been previously taken, we guess if
 it will be taken and if it is we begin speculatively executing from the
 address stored in the BTB.
\end_layout

\begin_layout Subsubsection
Cache
\end_layout

\begin_layout Paragraph
Modern processors make use of different levels of cache to allow for faster
 memory access.
 Ideally we would like to have an infinite amount of memory with no time
 cost for accessing it.
 The reality is that the larger memory is, the slower it becomes to access
 it [???].
 In order to get closer to the ideal modern processors make use of cache.
 It takes around 100 cycles for Intel's Intel i7-4770 (Haswell) architecture
 to access memory.
 Cache allows us get get closer to the ideal case by keeping commonly accessed
 memory closer to the CPU in levels of increasingly smaller, faster and
 more expensive (to manufacture) memory.
 The Haswell has 32KB of L1 data cache and 32KB of L1 code cache.
 These are located on the CPU itself [x] and can be accessed in around 4
 cycles[x].
 It also has 256KB of L2 cache and 8 MB of L3 cache.
 Caching works on the principal of locality of access.
 If you access memory in more or less the same area a lot, that acess is
 much faster than if you hop around from place to place.
 We should try to take advantage of cache in our VM's design.
\end_layout

\begin_layout Subsection
Traditional Implementation of High Level VMs
\end_layout

\begin_layout Subsubsection
Dispatch and Threading
\end_layout

\begin_layout Paragraph
Dispatch is the process of fetching, decoding and starting the next instruction
 to be run by a virtual machine [x].
\end_layout

\begin_layout Paragraph
The simplest way to implement a virtual machine is to make use of a switch
 statement in a loop.
 This is called switch dispatch.
 Here is a simplified version to illustrate:
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef enum { add /* ...
 */ } Inst; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void engine() 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	static Inst program[] = { add /* ...
 */ }; 
\end_layout

\begin_layout Plain Layout

	Inst *ip = program; 
\end_layout

\begin_layout Plain Layout

	int *sp; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

	for (;;) 
\end_layout

\begin_layout Plain Layout

		switch (*ip++) 
\end_layout

\begin_layout Plain Layout

		{ 
\end_layout

\begin_layout Plain Layout

		case add: 
\end_layout

\begin_layout Plain Layout

			sp[1]=sp[0]+sp[1]; 
\end_layout

\begin_layout Plain Layout

			sp++; 
\end_layout

\begin_layout Plain Layout

		break; 
\end_layout

\begin_layout Plain Layout

		/* ...
 */ 
\end_layout

\begin_layout Plain Layout

	}
\end_layout

\begin_layout Plain Layout

} 
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
This approach is problematic because the switch statement means that there
 is only ever a single entry in the Branch Target Buffer used for dispatch
 .
 This means that the number of mispredictions will be large as the target
 of the branch will change for each new instruction we branch to.
 This problem may even be magnified by the fact that this specific VM implementa
tion has far more instructions than usual as it requires several specialised
 versions of every instruction.
\end_layout

\begin_layout Paragraph
A faster alternative to switch dispatch is direct threading
\begin_inset CommandInset citation
LatexCommand cite
key "Ertl"

\end_inset

.
 The name threading comes from the idea of the execution threading its way
 from one instruction to the next [x].
 In direct threading the program is stored as a list of addresses of instruction
s and the code for each instruction includes a dispatch portion which jumps
 to the address of the next instruction to be executed.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef void *Inst; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void engine() 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	static Inst program[] = { &&add /* ...
 */ }; 
\end_layout

\begin_layout Plain Layout

	Inst *ip = program; 
\end_layout

\begin_layout Plain Layout

	int *sp; 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	goto *ip++; /* dispatch first VM inst.
 */ 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

add: 
\end_layout

\begin_layout Plain Layout

	sp[1]=sp[0]+sp[1]; 
\end_layout

\begin_layout Plain Layout

	sp++; 
\end_layout

\begin_layout Plain Layout

	goto *ip++; /* dispatch next VM inst.
 */ 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Another method is indirect threading.
 In indirect threading we keep a lookup table of the addresses of code for
 each instruction and have each instruction jump to the next by reading
 the opcode of the next instruction from the program, looking up the address
 of the code for that instruction in the table and then jumping to that
 instruction.
\end_layout

\begin_layout Standard
\begin_inset listings
inline false
status open

\begin_layout Plain Layout

typedef void *Inst; 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

void engine() 
\end_layout

\begin_layout Plain Layout

{ 
\end_layout

\begin_layout Plain Layout

	static Inst lookup[] = { &&add, &&sub /*...*/ }
\end_layout

\begin_layout Plain Layout

	static int program[] = { 0, /* ...
 */ }; 
\end_layout

\begin_layout Plain Layout

	int *ip = program; 
\end_layout

\begin_layout Plain Layout

	int *sp; 
\end_layout

\begin_layout Plain Layout

	
\end_layout

\begin_layout Plain Layout

	goto *ip++; /* dispatch first VM inst.
 */ 
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

add: 
\end_layout

\begin_layout Plain Layout

	sp[1]=sp[0]+sp[1]; 
\end_layout

\begin_layout Plain Layout

	sp++; 
\end_layout

\begin_layout Plain Layout

	goto lookup[*ip++]; /* dispatch next VM inst.
 */ 
\end_layout

\begin_layout Plain Layout

}
\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
Direct and inderect threading make much better use of the branch target
 buffer.
 Instead of a single entry in the BTB, with direct threading we have an
 entry per instruction, so instructions that commonly follow each other
 have a better chance of being predicted.
\end_layout

\begin_layout Standard
All code in this section is from or adapted from 
\begin_inset CommandInset citation
LatexCommand cite
key "M.AntonErtl2003"

\end_inset

.
\end_layout

\begin_layout Subsubsection
Registers VS Stacks
\end_layout

\begin_layout Paragraph
In a stack virtual machine, instructions act on members of the stack.
 Arguments and return values for instructions are often implicit and thus
 instructions can be smaller.
 For instance a stack implementation of a = b + c would first push b and
 c onto the stack, then call the add instruction which has no arguments.
 Add pops b and c off the stack and pushes b+c back onto the stack.
 This value is then popped off the stack and stored.
\end_layout

\begin_layout Paragraph
For a register machine, a similar piece of code would have values for b
 and c in registers and an add instruction is called with a, b and c as
 arguments.
 This instruction would compute b+c and store it in a regsiter.
\end_layout

\begin_layout Paragraph
Widely used process virtual machines make use of a stack architecture.
 Both the Java Virtual Machine (JVM) and Microsoft's Common Language Runtime
 (CLR) make use of stack virtual machines[x].
 
\end_layout

\begin_layout Subsubsection
JIT Compilation
\end_layout

\begin_layout Paragraph
Both the JVM and CLR make use of JIT compilation [x].
 JIT compilation allows for code that is executed often enough to be compiled
 into native machine code at runtime.
 JIT compilation does not preclude the bytecode of a many-instance application
 being shared but each instance of the application is JIT compiling that
 code.
 So it is likely that the same bytecode is being compiled in many different
 processes at the same time.
\end_layout

\begin_layout Subsection
VM Interpreter Reseach
\end_layout

\begin_layout Paragraph
James R.
 Bell introduced the concept of threaded code in 1973.
 The Fortran IV compiler was written to generate threaded code.
\begin_inset CommandInset citation
LatexCommand cite
key "Bell"

\end_inset


\end_layout

\begin_layout Paragraph
Yuhne Shi
\begin_inset CommandInset citation
LatexCommand cite
key "Shi2007"

\end_inset

 found that a well-implemented register VM is a more efficient option when
 speed of execution is more important than the size of the code to be executed.
\end_layout

\begin_layout Paragraph
Ertl and Gregg found that in their benchmarks 3.2%–13% of all executed instructio
ns were indirect branches and that switch dispatch on an architecture with
 a BRB resulted in 81%-98% branch prediction misses 
\begin_inset CommandInset citation
LatexCommand cite
key "M.AntonErtl2003"

\end_inset

.
 They also found that direct threading resulted in 50%-63% branch prediction
 misses.
\end_layout

\begin_layout Subsection
Our Implementation
\end_layout

\begin_layout Subsubsection
Virtual Machine Design Details
\end_layout

\begin_layout Paragraph
The virtual machine described in this treatise is a register machine.
 It has 6 general purpose registers and 3 special purpose registers.
 The VM is for a dynamically typed language.
 Each register stores 'values' and all instructions act on those values.
 The type of a value is stored together with the data for that value.
 These are implemented in C as tagged unions.
 The VM has only two types: integer and pointer.
 
\end_layout

\begin_layout Paragraph
The 3 special purpose registers are:
\end_layout

\begin_layout Enumerate
The program counter (pc), which keeps track of where we are in the program
\end_layout

\begin_layout Enumerate
The frame pointer (fp), which points to the bottom of the latest stack frame
\end_layout

\begin_layout Enumerate
The type state (ts), which keeps track of the current state of types in
 the registers
\end_layout

\begin_layout Subsubsection
Type-Mapping
\end_layout

\begin_layout Paragraph
The virtual machine does not make use of the usual opcode and arguments
 arrangment used in register machine interpreters.
 Usually, the interpreter reads in some instruction stored as an opcode
 and the arguments for that opcode at the same time.
 In 
\emph on
fig 2
\emph default
 we see a 16 bit instruction composed of a 4 bit opcode in the high bits,
 followed by two 6 bit operands or aguments.
 The interpreter performs the necessary shifts and bitmasking to get the
 values out of the fields.
\end_layout

\begin_layout Standard
\begin_inset Float figure
wide false
sideways false
status open

\begin_layout Plain Layout
\begin_inset Caption Standard

\begin_layout Plain Layout
\begin_inset Graphics
	filename /home/stevetest/opcode.png
	scale 60

\end_inset


\end_layout

\end_inset


\end_layout

\end_inset


\end_layout

\begin_layout Paragraph
In our VM instructions for programs are stored as opcodes only with no arguments.
 That is because we have a version of each instruction for every combination
 of registers as inputs.
 Because we have 6 registers and a maximum of two arguments per instruction
 that means that we can have a maximum of 6^2 versions of each instruction.
 This saves us the process of extracting arguments at the expense having
 to have more versions of the instruction[why are we doing it this way actually?
].
 The opcode implicitly stores the argument information.
\end_layout

\begin_layout Paragraph
The opcode is not the only information the VM uses to select code, however.
 The 
\emph on
ts
\emph default
 register keeps a record of the type of every register.
 It is a 6 bit number where each bit tells us the current type of a register.
 Thus for every opcode, there are 2^6 different states the VM could be in.
 With this information we know the arguments and types and can jump to specialis
ed code that acts on arguments of those types.
 A good way to think about it is to imagine it as a 2D lookup table (even
 though the implementation is 1D).
 On the y-axis we have the opcodes for all the versions of the instructions
 and on the x-axis we have the current state from 0 to 63.
 At the intersection of these we store the address of the code we jump to
 for that instruction.
\end_layout

\begin_layout Paragraph
Now since we only have integers and pointers it may, at first glace, seem
 pointless to have specialised instructions since most of the time using
 pointers in an instruction meant for integers is illegal.
 However this method elliminates the type checking involved in instructions
 for a dynamic-ISA VM.
 Normally for each instruction we would have to check the validity of the
 arguments first before we can perform the instruction, but with this method
 we already know the types and so we can just jump directly to code for
 those types or an error if the arguments are illegal.
\end_layout

\begin_layout Subsubsection
Indirect Threading
\end_layout

\begin_layout Paragraph
This VM will make use of indirect threading.
 Though indirect threading is slower than direct threading [x] because it
 must first complete the lookup step before it can branch to the next instructio
n, the program code used by the VM is intended to be shared by many instances
 of the VM.
 This cannot be achieved with direct threading as the addresses of each
 instruction in each instance may be different[x].
 Also because our dispatch is based on the runtime state of the virtual
 machine (the st register) even if addresses were the same between instnces
 we can't represent code in terms of those addresses as we don't know the
 state information until runtime so we can't choose which address should
 be used to replace the opcode.
 With Indirect threading's lookup table we can share the code in its opcode
 form and perform the correct jumps for each instance of the VM by consulting
 the state register and looking up the addresses in the lookup table.
\end_layout

\begin_layout Paragraph
\begin_inset Newpage newpage
\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "/home/stevetest/a"
options "plain"

\end_inset


\end_layout

\end_body
\end_document
